trait Natural {
    type Nat : * =
      data Zero
    | data Succ v : Nat -> Nat

    // Implicit smart constructors
    sig Zero : data Zero
    sig Succ : Nat -> data Succ (v:Nat)

    sig (+) : Nat -> Nat -> Nat
    def (+) m =
        when self
        is Zero -> m
        is Succ -> Succ $ self.v + m
}

trait Vect {
    use Natural

    type Vect : Nat -> * -> * =
      data Nil      : forall a. Vect Zero a
    | data Cons h t : forall (n:Nat) a. a -> Vect n a -> Vect (Succ n) a

    sig head : forall (n:Nat) a. self -> a for Vect (Succ n) a
    def head = self.h

    sig tail : forall (n:Nat) a. self -> Vect n a for Vect (Succ n) a
    def tail = self.t

    -- How can we encode this in the type level?
    sig (++) : forall (n:Nat) (m:Nat) a. self -> Vect m a -> Vect (n + m) a for Vect n a
    def (++) l =
        when l
        is Nil  -> l
        is Cons -> self.h :: $ self.t ++ l
}

impl Main {
    use Natural
    use Vect

    sig l1 : Vect 2 Int -- In the type leve 2 == Succ 1, 1 == Succ 0, 0 == Zero
    def l1 = 1 :: 2 :: []

    sig l2 : Vect 2 Int
    def l2 = 3 :: $ tail l1

    sig l3 : Vect 4 Int
    def l3 = l1 ++ l2
}

type Equality {
    type (:=:) _ _ = data refl : forall a. a :=: a

    sig antisymetric : forall a b. (a :=: b) -> (b :=: a)
    def antisymetric refl = refl

    sif transitive : forall a b c. (a :=: b) -> (b :=: c) -> (a :=: c)
    sig transitive refl refl = refl
}